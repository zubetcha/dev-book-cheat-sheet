# Chapter 07 - HTTP/2의 신택스: 프로토콜 재정의

## 7.1 HTTP/2

- 데이터 표현이 HTTP/1.1과는 크게 달라짐
  - 스트림(1.1의 파이프라인에 가까움)을 사용해 바이너리 데이터를 다중으로 송수신하는 구조로 변경
  - 스트림 내 우선 순위 설정과 서버 사이드에서ㅜ 데이터 통신을 하는 서버 사이트 푸시 구현
  - 헤더 압축
- HTTP가 제공하는 기본 4개 요소는 변경되지 않음
  - 메서드, 헤더, 스테이터스, 바디
  - 사용하는 쪽(클라이언ㅌ, 서버)을 제외한 통신 레벨에서는 큰 변경이 없음

**프로토콜 개선사항**

- 캐시(max-age): 통신 자체를 취소
- 캐시(ETag, Date): 변경이 없으면 바디를 취소
- Keep-Alive: 액세스마다 연결에 걸리는 시간(1.5TTL)을 줄임
- 압축: 응답 바디 크기 절감
- 청크: 응답 전송 시작을 빠르게 함
- 파이프라이닝: 통신 다중화

### 7.1.1 스트림을 이용한 통신 고속화

- 텍스트 기반 프로토콜에서 바이너리 기반 프로토콜로 변화
- HTTP/1.1까지는 하나의 요청이 TCP 소켓을 독점
  - 하나의 오리지널 서버에 대해 2~6개의 TCP 접속을 해서 병렬화
- HTTP/2에서는 하나의 TCP 접속 안에 스트림이라는 가상의 TCP 소켓을 만들어 통신

**스트림**

- 프레임에 따른 플래그로 간단히 만들고 닫을 수 있는 규칙으로 구성
- 일반 TCP 소켓과 같은 핸드셰이크는 불필요
- 따라서 ID 값과 TCP 통신 용량이 허락하는 한, 손쉽게 몇 만번의 접속이라도 병렬화 가능

<br/>

**공통 헤더**

| 요소              | 크기                 | 의미                                               |
| ----------------- | -------------------- | -------------------------------------------------- |
| Length            | 24                   | 페이로드 크기 (공통 헤더는 제외)                   |
| Type              | 8                    | 프레임 종류                                        |
| Flags             | 8                    |                                                    |
| R                 | 1                    | 예약 영역 (항상 0)                                 |
| Stream Identifier | 31                   | 스트림 식별자. 같은 값이면 같은 스트림 관련 프레임 |
| Frame Payroad     | Length로 지정한 길이 | 프레임의 실제 데이터                               |

Stream Identifier

- 같은 Stream Identifier를 가진 프레임은 수신 시에 그룹화됨
- 또한 같은 스트림에서 나온 데이터로 취급됨
- 0은 예약되어 있기 때문에 사용하면 에러 발생
- 홀수는 클라이언트 > 서버, 짝수는 서버 > 클라이언트로의 통신에 사용됨

<br/>

**프레임 종류**

| 종류          | 데이터                                        | 선택적 데이터                          | 설명                                                                 |
| ------------- | --------------------------------------------- | -------------------------------------- | -------------------------------------------------------------------- |
| HEADERS       | 헤더                                          | 의존하는 스트림과 우선도, 배타 플래그  | 압축된 헤더. 우선도는 최초 헤더만 사용 가능                          |
| DATA          | 데이터                                        |                                        | 바디의 송신에서 사용                                                 |
| PRIORITY      | 의존하는 스트림, 우선도, 배타 플래그          |                                        |                                                                      |
| RST_STREAM    | 오류 코드                                     |                                        | 오류 정보를 반환하고, 스트림을 바로 종료                             |
| SETTINGS      | 식별자(16비트), 설정값(32비트)의 조가 여러 개 |                                        |                                                                      |
| PUSH_PROMISE  | 스트림 ID                                     | 요청 헤더 필드                         | 서버 푸시 시작 예약                                                  |
| PING          | 8바이트 데이터                                |                                        | 응답 속도 측정용 프레임 <br/> PING을 받으면 ACK 플래그를 설정해 반환 |
| GOAWAY        | 최종 스트림 ID, 오류 코드                     | 추가 디버그 정보                       | 커넥션을 종료                                                        |
| WINDOW_UPDATE | 윈도우 크기                                   | 추가로 수신할 수 있는 데이터 크기      |                                                                      |
| CONTINUATION  |                                               | HEADERS/PUSH_PROMISE에 이어지는 데이터 |                                                                      |

- SETTINGS에서 변경 가능한 설정
  - 헤더 테이블 크기
  - 푸시 허가
  - 최대 병렬 스트림 수
  - 초기 윈도우 크기
  - 최대 프레임 크기
  - 최대 헤더 리스트 크기

<br/>

### 7.1.2 HTTP/2의 애플리케이션 계층

- HTTP/1.0: 단순히 데이터를 운반하는 상자 역할
- HTTP/1.1: 텍스트 프로토콜, 하나의 요청 중 다른 요청 처리 불가
- HTTP/2.0: 바이너리화, 서로 독립적으로 분리되어 있는 프레임 구조

### 7.1.3 플로 컨트롤

> 플로 컨트롤  
> 스트림을 효율적으로 흐르도록 하는 통신량 제어 처리로,  
> 서로 통신 속도 차이가 많이 나는 기기 사이에 빠른 쪽이 느린 쪽으로 대량의 패킷을 전송해 처리할 수 없게 되는 사태 방지 목적으로 이용

- HTTP/2는 인터넷(TCP/IP) 4계층 모델 중 어플리케이션 레이어에 해당하지만 내부는 트랜스포트 레이어에 가까움
  - 플로 컨트롤로 TCP 소켓과 거의 같은 기능 구현
- 구체적으로 윈도우 크기를 관리함으로써 제어
  - 패킷을 보내는 쪽은 상대방 윈도우의 최대 버퍼 크기만큼까지 데이터 전송
  - 패킷을 받는 쪽은 버퍼에 여유가 생기면 `WINDOW_UPDATE` 프레임을 이용해 여유 버퍼 크기를 전송한 쪽에 반환
- `SETTINGS` 프레임을 사용하면 초기 윈도우 크키, 최대 병렬 스크림 수, 최대 프레임 크기, 최대 헤더 리스트 크기 등과 같은 속도와 관련된 매개변수 조정 가능

### 7.1.4 서버 푸시

- HTTP/2부터 서버 푸시를 이용해 우선 순위가 높은 콘텐츠를 클라이언트가 요구하기 전 전송할 수 있게 됨
- 웹소켓과 같은 양방향 통신은 아님
- css, 자바스크립트, 이미지 등 웹페이지를 구성하는 파일 다운로드 용도로 이용
- 서버가 푸시한 데이터는 캐시에 들어가며, 이후 클라이언트가 요청 시 즉시 다운로드된 것 처럼 보이도록 함

### 7.1.5 HPACK을 이용한 헤더 압축

- 헤더는 HPACK이라는 방식으로 압축됨
- 대부분의 데이터 압축 알고리즘은 딕셔너리와 딕셔너리 키 배열이라는 두 가지 데이터를 생성
  - 같은 길이의 문장이 많을수록 딕셔너리의 항목은 적어짐
  - 같은 키가 많이 사용될수록 압축률은 올라감
- HPACK은 일반 압축 알고리즘과 달리 사전에 사전을 가지고 있음
  - HTTP/2에서는 정적 테이블(static table)이라는 이름으로 딕셔너리에 빈번하게 출현하는 헤더 이름과 값을 테이블로 가지고 있음
  - 같은 커넥션에서 등장한 HTTP 헤더는 인덱스화되어 동적 테이블에 저장 후, 다시 등장할 때 인덱스 값만으로 표현

### 7.1.6 SPDY와 QUIC

#### SPDY

- SPDY(스피디)는 구글이 개발한 HTTP 대체 프로토콜로, 거의 그대로 HTTP/2가 됨
- 개발 목적은 HTTP가 개선해 온 전송 속도를 더욱 향상시키기 위함

#### QUIC

- HTTP와 같은 층인 TCP 소켓상에 구현됐지만 구글은 속도를 더 빠르게 하기 위해 UDP 소켓상에 QUIC(퀵)이라는 프로토콜을 준비
  - `TCP`는 재전송 처리, 폭주 제어, 순서 정렬, 에러 정정 등의 고급 기능으로 속도가 다소 느림
  - `UDP`는 위와 같은 고급 기능을 제거 해 가볍게 경량화한 프로토콜
- TCP의 고급 기능은 QUIC에 자체적으로 구현

<br/>

## 7.2 Fetch API
