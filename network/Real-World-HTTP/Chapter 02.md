# Chapter 02 - HTTP/1.0의 시맨틱스: 브라우저 기본 기능의 이면

## 2.1 단순한 폼 전송 (x-www-form-unlencoded)

- HTTP는 한 번 응답할 때 하나의 파일만 반환

<br/>

## 2.2 폼을 이용한 파일 전송

- HTML의 폼에서는 옵션으로 멀티파트 폼이라는 인코딩 타입 선택 가능
- 멀티 폼 형태의 헤더를 출력했을 때, 헤더에는 Content-Type multipart/form-data 외에도 `경계 문자열`이라는 추가적인 속성이 부여되어 있음

  - 여러 개의 파일을 보낼 때 각 파일을 구분하여 블록으로 나눠주는 역할

<br/>

## 2.3 폼을 이용한 리디렉트

300번대 스테이터스 코드를 사용한 리디렉트의 문제점

- URL의 길이는 2,000자 이내라는 기준이 있어 GET의 쿼리로 보낼 수 있는 데이터양에 한계가 있음
- 데이터가 URL에 포함되어 있으므로 전송하는 내용이 액세스 로그 등에 남을 우려가 있음 (보안)

위와 같은 문제를 피하기 위해 HTML의 폼을 이용해서 리디렉트하기도 함.

<br/>

## 2.4 콘텐트 니고시에이션

> `콘텐트 니고시에이션`  
> 통신 방법을 최적화하고자 하나의 요청 안에서 서버와 클라이언트가 서로 최고의 설정하는 공유하는 시스템

<br/>

**콘텐트 니고시에이션 대상과 헤더**
| 요청 헤더 | 응답 | 니고시에이션 대상 |
| --------------- | --------------------------------- | ----------------- |
| Accept | Content-Type | MIME 타입 |
| Accept-Language | Content-Language 헤더 / html 태그 | 표시 언어 |
| Accept-Charset | Content-Type 헤더 | 문자의 문자셋 |
| Accept-Encoding | Content-Encoding 헤더 | 바디 압축 |

<br/>

### 2.4.1 파일 종류 결정

```
// 웹 서버가 webp를 지원하면 webp를, 그렇지 않으면 png 등 다른 포맷(우선 순위 0.8)을 서버에 보낼 것을 요구
Accept: text/html,application/xhtml+xml, application/xml;q=0.9,image/webp,*/*;q=0.8
```

- `,(콤마)`로 항목을 나눔
- q는 품질 계수를 의미하며 0부터 1까지의 수치로 설정
  - 기본값: 1.0
  - 기본값일 경우 q 생략
- 웹 서버는 우선순위를 해석해 위에서부터 차례로 지원하는 포맷을 찾고, 일치하는 포맷을 반환

  - 일치하는 형식의 파일이 없으변 406 Not Acceptable 오류 반환

### 2.4.2 표시 언어 결정

```
Accept-Language: en-US,en;1=0.8,ko;q=0.6
```

- 클라이언트가 지원하는 언어 종류

#### 2.4.3 문자셋 결정

```
Accept-Charset: windows-949,utf-8;q=0.7,*;q=0.3
```

- 현재는 브라우저가 모든 문자셋 인코더를 내장하고 있기 때문에 미리 니고시에이션 할 필요가 없어져 Accept-Charset을 보내고 있지 않음
- 문자셋은 MIME 타입과 세트로 Content-Type 헤더에 실려 전송됨

  - ```
    Content-Type: text/html; charset=UTF-8
    ```

- HTML의 경우 문서 안에도 기술 가능
  - ```
    <meta http-equiv="Content-Type> content="text/html; charset=UTF-8">
    ```
  - HTTP 헤더와 똑같은 지시를 문서 내부에 삽입해 반환하는 태그
- HTML5
  - ```
    <meta charset="UTF-8">
    ```

### 2.4.4 압축을 이용한 통신 속도 향상

```
Accept-Encoding: deflate, gzip
```

- 콘텐츠 압축 목적: 전송 속도 향상
  - 텍스트 파일은 1/10 크기로 압축
  - JSON 파일은 1/20 정도의 크기로 압축
- 통신에 걸리는 시간보다 압축과 해제가 짧은 시간에 이루어지므로, 콘텐츠를 압축하면 웹페이지를 표시할 때 걸리는 전체적인 처리 시간을 단축시킬 수 있음
- 또한 콘텐츠를 압축하면 데이터 사용 비용 부담이 줄어들고, 모바일 단말에서는 전력 소비량도 줄일 수 있음
- 콘텐츠 압축 니고시에이션은 모두 HTTP의 헤더 안에서 완료함

- <br/>

## 2.5 쿠키

- 서버 → 클라이언트로 파일 보관을 지시할 때 사용
- HTTP 헤더 기반으로 구현됨

**쿠키의 문제점**

- `영속성` → 어떠한 상황에서도 확실하게 저장이 되는 것은 아님
  - 시크릿 모드 혹은 브라우저의 보안 설정에 따라 세션이 끝나면 `초기화`되거나 쿠키를 보관하라는 `서버의 지시를 무시`할 수도 있음
  - 사라져도 문제가 없는 정보나 서버의 정보로 복원할 수 있는 자료를 저장하는 용도에 적합
- `용량` → 쿠키의 최대 크기는 4KB로 정해져 있음
  - 쿠키는 헤더이기 때문에 항상 통신 시 헤더에 추가되기 때문에 저장하는 파일의 용량이 커지면 요청과 응답 속도에 영향을 미칠 수 있음
- `보안` →
  - HTTP 통신에서는 쿠키가 평문으로 전송됨
  - 암호화하더라도 사용자가 자유롭게 접근할 수 있고 쿠키를 수정할 수도 있음
  - 인증 정보나 사라져도 문제가 없는 정보만 쿠키에 저장하는 게 좋음

**쿠키 제한 속성**
| 속성 | 설명 |
| --- | --- |
| Expires, Max-Age | - 쿠키의 수명 설정 <br/> - Max-Age: 초단위 지정 <br/> - Expires: 날짜 관련 문자열 해석 ex. Wed, 09 June 2021 10:18:14 GMP |
| Domain | - 클라이언트에서 쿠키를 전송할 대상 서버 <br/> - 생략 시 쿠키를 발행한 서버로 자동 지정 |
| Path | - 클라이언트에서 쿠키를 전송할 대상 서버의 경로 <br/> - 생략 시 쿠키를 발행힌 서버의 경로로 자동 지정 |
| Secure | - 클라리언트에서 서버로 쿠키 전송 시 HTTPS를 사용한 보안 접속일 때만 전송 |
| HttpOnly | - 자바스크립트 엔진으로부터 쿠키를 감출 수 있음 <br/> - 자바스크립트로 쿠키 접근 불가 (document.cookies) <br/> - 크로스 사이트 스크립팅 등 악의적인 자바스크립트가 실행되는 보안 위험에 대한 방어를 할 수 있음 |
| SameSite | - 크롬 브라우저 버전 51에서 도입한 속성 <br/> - 같은 오리진의 도메인에 전송 |

<br/>

## 2.6 인증과 세션

### 2.6.1 BASIC 인증과 Digest 인증

- 클라이언트에서 매번 유저명과 패스워드를 전송하는 방식

**BASIC 인증**

```
Authorization: "Basic dXNlcjpwYXNz"
```

- 기본 인증 방식
- 유저명과 패스워드를 `Base64`로 인코딩한 것
- Base64 인코딩은 `가역변환`이므로 복원하여 원래 유저명과 패스워드를 추출할 수 있음
- SSL/TLS 통신을 사용하지 않은 상태에서 통신이 감청되면 손쉽게 로그인 정보가 유출될 우려 존재

**Digest 인증**

- 해시 함수 이용
  A > B는 쉽게 계산할 수 있지만, B > A는 쉽게 계산할 수 없음

### 2.6.2 쿠키를 사용한 세션 관리

- 현재는 아래와 같은 이유로 Basic 인증과 Digest 인증 방식 모두 많이 사용되지 않음
  - 톱페이지에서 사용자 고유 정보를 제공할 수 없어 톱페이지 접속과 동시에 로그인 창 표시 필수 (UX 저하)
  - 매 요청마다 유저명과 패스워드를 보내고 계산해서 인증해야 함. 특히 Digest 방식은 계산량이 많음.
  - 로그인 화면을 사용자화하는 게 불가능
  - 명시적인 로그오프 불가능
  - 로그인한 단말 식별 불가능
- 최근 많이 사용되는 방식은 `폼`을 이용한 `로그인` + `쿠키`를 이용한 `세션 관리` 조합

**방식**

- 클라이언트는 폼으로 유저 ID와 패스워드 전송
  - 유저 ID와 패스워드를 직접 송신하므로 `SSL/TLS` 필수
- 서버는 세션 토큰을 관계형 데이터베이스나 key-value형 데이터베이스에 저장
  - 세션 토큰은 쿠키를 통해 클라이언트로 전달
- 두 번째 이후의 접속부터는 쿠키를 재전송해서 로그인된 클라이언트임을 서버에 전달

### 2.6.3 서명된 쿠키를 이용한 세션 데이터 저장

- 서버 > 클라이언트로 전자 서명된 데이터 전송
- 클라이언트가 서버로 쿠키를 재전송하면 서버는 서명 확인
- 서명을 하는 것도 확인하는 것도 서버 담당
  - 공개 키와 비밀 키 모두 서버에서 보유
- 서버 측에서 데이터 저장 시스템을 준비할 필요가 없다는 장점이 있음

<br/>

## 2.7 프록시

- HTTP 등의 통신 중계 역할
- 프록시와 비슷한 것으로는 `게이트웨이`가 있음
- HTTPS 통신의 프록시 지원은 HTTP/1.1에서 추가된 `CONNECT` 메서드 이용
- 그 외 부가적인 기능
  - 캐시 → 웹 서버 부담은 줄이고 사용자가 빠르게 페이지를 볼 수 있도록 해줌
  - 보안 → 외부 공격으로부터 네트워크를 보호하는 방화벽 역할
  - 필터링 → 저속 통신 회선용으로 데이터를 압축하거나 컨텐츠 등을 필터링

**프록시 구조**

- GET 등의 메서드 다음에 오는 경로명 형식만 바뀜
- 프록시를 설정하면 유닉스 형식 → URL 형식이 됨
  - 유닉스 → /helloworld처럼 슬래시로 시작
  - URL → 스키마가 추가돼 `http://`, `https://` 로 시작

**프록시 서버 보안**

- 인증을 이용해 보호해야 하는 경우 `Proxy-Authenticate` 헤더 사용
- 예전부터 관용적으로 `X-Forwarded-For` 헤더를 사용했지만, RFC7239에서 표준화되면서 `Forwarded` 헤더가 도입됨

<br/>

**`프록시`와 `게이트웨이` 비교**

| 프록시     | - 통신 내용을 이해함 <br/> - 필요에 따라서 콘텐츠를 수정하거나 서버 대신 응답                                              |
| ---------- | -------------------------------------------------------------------------------------------------------------------------- |
| 게이트웨이 | - 통신 내용을 그대로 전송 <br/> - 내용 수정 불가 <br/> - 클라이언트에서는 중간에 게이트웨이가 존재하는 것을 알아채면 안 됨 |

<br/>

## 2.8 캐시

- `GET, HEAD` 메서드 이외에는 기본적으로 캐시가 되지 않음

### 2.8.1 갱신 일자에 따른 캐시

- 웹 서버는 대부분 다음과 같은 헤더를 응답에 포함
  ```tsx
  Last-Modified: Wed, 08 Jun 2016 15:23:45 GMT
  ```
- 웹 브라우저가 캐시된 URL을 다시 읽을 때는 서버에서 반환된 일시를 그대로 `If-Modified-Since` 헤더에 넣어 요청을 전송
  ```tsx
  If-Modified-Since: Wed, 08 Jun 2016 15:23:45 GMT
  ```
- 웹 서버는 요청에 포함된 `If-Modified-Since`의 일시와 서버의 콘텐츠 일시 비교
  - 콘텐츠가 변경됐으면 `Status Code 200 OK`을 반환하고, 콘텐츠를 바디에 실어서 응답
  - 변경되지 않았으면 `Status Code 304 Not Modified`를 반환하고, 응답에 바디를 포함시키지 않음

### 2.8.2 Expires

- 갱신을 이용하는 캐시는 캐시의 유효성을 검사하기 위한 비용이 듦
- 검사 비용을 없애기 위한 방법이 HTTP/1.0에 도입 → Expires 헤더 이용
- Expires 헤더에는 날짜와 시간이 포함됨
  - 지정한 기한 내 → 신선한 데이터 → 요청 전송 X
  - 기한 지남 → 신선하지 않은 데이터로 판단
- 클라이언트에서 판단하고 처리하기 때문에 서버에 변경사항을 묻지 않음
- HTTP/1.1에서 변경할 일이 없는 콘텐츠라도 최대 1년의 캐시 수명을 설정하자는 가이드라인이 추가됨

### 2.8.3 Pragma: no-cache

- HTTP/1.0부터 추가된 Pragma 헤더에 유일하게 들어갈 수 있는 사양이 `no-cache`
- no-cache는 HTTP/1.1부터 Cache-Control로 통합됨

> 💡 no-cache  
> 요청한 콘텐츠가 이미 저장돼 있어도, 원래 서버에서 가져오라고 프록시 서버에 지시하는 것

### 2.8.4 ETag 추가

- ETag(Entity Tag)는 갱신 일시가 아닌 파일의 해시 값으로 비교
- 서버 → 클라이언트 응답 헤더 Etag 포함
- 클라이언트 → 서버 요청 헤더 If-None-Match에 Etag 헤더로 받은 값 설정

### 2.8.5 Cache-Control (1)

- Etag와 같은 시기에 HTTP/1.1에서 추가된 헤더로, `Expires`보다 우선해서 처리됨
- 개인 정보 보호 목적으로 사용할 수 없음
- 아래 표와 같은 키 사용 가능

| public     | - 같은 컴퓨터를 사용하는 복수의 사용자간 캐시 재사용 허가                                                                  |
| ---------- | -------------------------------------------------------------------------------------------------------------------------- |
| private    | - 같은 컴퓨터를 사용하는 다른 사용자 간 캐시 재사용 불허 <br /> - 같은 URL에서 사용자마다 다른 콘텐츠가 돌아오는 경우 이용 |
| max-age=n  | - 캐시의 신선도를 초단위로 설정                                                                                            |
| s-maxage=n | - 공유 캐시에 대한 설정값                                                                                                  |
| no-cache   | - 캐시가 유효한지 매번 문의 <br />- max-age=0과 거의 같음                                                                  |
| no-store   | - 캐시하지 않음                                                                                                            |

- 콤마(,)로 구분 가능하지만 내용면에서 다음과 같이 조합함
  - private, public 중 하나, 혹은 설정하지 않음 (기본은 private)
  - max-age, s-maxage, no-cache, no-store 중 하나

### 2.8.6 Cache-Control (2)

- 프록시 서버에도 캐시 관련한 지시 가능
- 프록시에 대한 캐시 요청은 잘 사용하지 않기 때문에 캐시 관련 설정값은 책 참고 (96p)
  - 클라이언트 → 프록시 서버 요청 헤더 값
  - 서버 → 프록시 서버 응답 헤더 설정 값
    - 서버 → 프록시 서버 응답 값에는 서버 → 클라이언트로 보내는 응답 값도 모두 유효함

### 2.8.7 Vary

- 같은 URL이라도 클라이언트에 따라 반환 결과가 다름을 나타내는 헤더
  - ex) 페이지 접근 기기가 다른 경우, 사용하는 언어가 다른 경우
- `표시가 바뀌는 이유에 해당하는 헤더명`을 Vary 헤더에 나열함으로써 잘못된 콘텐츠의 캐시로 사용되지 않도록 함

```tsx
Vary: User - Agent, Accept - Language;
```

<br/>

## 2.9 Referrer

- 사용자가 어느 경로로 웹사이트에 도달했는지 서버가 파악할 수 있도록 클라이언트가 서버에 보내는 헤더
  - 클라이언트가 링크를 클릭해서 도달했을 때 → 링크 URL
  ```tsx
  Referer: http://www.example.com/link.html
  ```
  - 웹페이지가 리소스를 요청하는 경우 → 리소스를 이용하는 HTML 파일
- 북마크에서 선택하거나 주소창에서 키보드로 직접 입력했을 때는 태그를 전송하지 않거나 `Referer:about:blank`로 전송
- GET 요청의 Request parasm는 리퍼러를 통해 외부로 노출될 수 있기 때문에 개인정보를 Request params에 담아서는 안 됨

2014년에 제안된 (철자가 수정된) 리퍼러 정책 설정 방법

- Referrer-Policy 헤더
- <meta name=”referrer” content=”설정값”>
- <a> 태그 등 몇 가지 요소에 referrerpolicy 속성 및 rel=”nonreferrer” 속성 설정
- 설정값
  | no-referrer | 전송 X |
  | --- | --- |
  | no-referrer-when-downgrade | 현재 기본 동작과 마찬가지로 HTTPS → HTTP로 요청할 때는 전송X |
  | same-origin | 동일 도메인 내의 링크에 대해서만 전송 |
  | origin | 상세 페이지가 아닌 톱 페이지에 링크된 도메인 이름만 전송 |
  | strict-origin | origin과 같지만 HTTPS → HTTP일 때는 전송 X |
  | origin-when-crossorigin | 같은 도메인 → 완전한 리퍼러
  다른 도메인 → 도메인 이름만 |
  | strict-origin-when-crossorigin | origin-when-corssorigin과 같지만 HTTPS → HTTP일 때는 전송 X |
  | unsafe-url | 항상 전송 |

<br/>

## 2.10 검색 엔진용 콘텐츠 접근 제어

- 크롤러의 접근 제어 방법

  - robots.txt
  - 사이트맵

### 2.10.1 robots.txt

- 서버 콘텐츠 제공자가 크롤러에 접근 허가 여부를 전하기 위한 프로토콜
- robots.txt에는 읽는 것을 금지할 크롤러의 이름과 경로를 지정할 수 있음

```tsx
User-agent: * // 모든 크롤러
Disallow: /cgi-bin/ // 경로
Disallow: /tmp
```

- robots.txt와 비슷한 내용을 HTML 메카 태그로도 기술할 수 있음
  - 단, 메타 태그보다 robots.txt가 우선함
  - 메타 태그에는 더 자세히 기술 가능

```tsx
<meta name='robots' content='noindex' />
```

### 2.10.3 사이트맵

- 웹사이트에 포함된 페이지 목록돠 메타데이터를 제공하는 xml 파일
