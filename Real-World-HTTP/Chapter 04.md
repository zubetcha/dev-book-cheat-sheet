# Chapter 04 - HTTP/1.1의 신택스: 고속화와 안정성을 추구한 확장

#### HTTP/1.1 주요 변경사항

- 통신 고속화
  - Keep-Alive가 기본적으로 유효
  - 파이프라이닝
- TLS에 의한 암호화 통신 지원
- 새 메서드 추가
  - PUT과 DELETE가 필수 메서드가 됨
  - OPTION, TRACE, CONNECT 메서드 추가
- 프로토콜 업데이트
- 이름을 이용한 가상 호스트를 지원
- 크기를 사전에 알 수 없는 콘텐츠의 청크 전송 인코딩 지원

### 4.1 통신 고속화

- 캐시 또한 HTTP/1.1의 기능
- 캐시는 콘텐츠 리소스의 통신 최적화 기술
- `Keep-Alive`와 `파이프라이닝`은 범용적으로 모든 HTTP 통신을 고속화 하는 기능

#### Keep-Alive

![keep-alive](https://www.haproxy.com/assets/posts/perisitent-connection.png)

| Keep-Alive 유무 | 설명                                        |
| :-------------: | ------------------------------------------- |
|        X        | 하나의 요청마다 통신을 닫음 (복수의 커넥션) |
|        O        | 연석된 요청에는 접속 재이용 (커넥션 지속)   |

- HTTP의 아래층인 TCP/IP 통신을 효율화하는 구조
- 접속 재이용의 장점
  - TCP/IP의 접속까지의 대기 시간 단축
  - 모바일 통신에서는 배터리 낭비 감소
- HTTP/1.1에서는 Keep-Alive 동작이 기본으로 되어 있음
- 연결 유지 기한
  - 타임아웃 or 서버/클라이언트 중 한 쪽에 다음 헤더 부여 시까지
    ```jsx
    Connection: Close;
    ```
- 통신 지속 시간 동안 OS 리소스 소비 → 실제 통신은 없는데 접속을 유지하는 것은 낭비

### 파이프라이닝

![파이프라이닝](https://blog.kakaocdn.net/dn/bpdV4n/btrub9VkLO4/2UHDW7xWK6x9RIKKorkkQ0/img.png)

- 최초 요청이 완료되기 전에 다음 요청을 보내는 고속화 기술
- 다음 요청까지의 대기 시간 X → 네트워크 가동률 증가, 성능 향상
- 서버는 요청이 들어온 순서대로 응답 반환
- 브라우저, 서버, 프록시 등의 설정에 따라 제대로 동작하지 않을 수 있음
- HTTP/2에서 스트림이라는 구조로 재탄생

> HOL (Head of Line Blocking)

<br/>

### 4.2 전송 계층 보안 (TLS)

- 암호화되어 통신을 엿보거나 변경할 수 없는 양방향 통신

#### 해시 함수

**해시 함수의 특징**

- 같은 알고리즘과 같은 데이터를 입력하면, 생성되는 결과 값은 같다. `h(A) = X`
- 알고리즘이 같으면 해시 값의 길이는 고정된다.
- 해시 값에서 원본 데이터를 유추하기 어렵다. `h(A) = X`의 X에서 A를 찾기 어렵다. (약한 충돌 내성)
- 같은 해시 값을 생성하는 다른 두 개의 데이터를 찾기 어렵다. h(A) = h(B)가 되는 임의의 데이터 A, B를 찾기 어렵다. (강한 충돌 내성)

**해시 값의 용도**

- 다운로드한 파일이 깨지지 않았는지 확인 (체크섬, 핑거프린트)
  - 1바이트라도 데이터가 다르면 해시 값이 바뀌기 때문
- 빠른 비교
  - 데이터 파일 내용을 일일히 비교하지 않고 해시 값으로만 비교 (ex. Git)
- 내용 동일성 판단

**해시 값 확인 CLI**

```
// Mac OS
md5 sample.rst

// Window
fciv.exe sample.rst
```

#### 공통 키 암호와 공개 키 암호 그리고 디지털 서명

- 암호화에서 중요한 것은 변환 알고리즘이 알려져도 안전하게 통신할 수 있게 하는 것
- 일반적으로 사용하는 방식: 알고리즘 공개 + 암호화에 필요한 키 별도로 준비
- TLS에서의 사용 방식 종류
  | 종류 | 특징 |
  | --- | --- |
  |`공통 키` 방식| - `대칭 암호` <br/> - 데이터를 전송하는 쪽과 받는 쪽 모두 **같은 키** 사용 <br/> - 통신하는 측 끼리 키 공유 필요|
  |`공개 키` 방식| - `비대칭 암호` <br /> - **공개 키**와 **비밀 키** 필요 <br /> - 공개 키 → 암호화 하는 키 <br/> - 비밀 키 → 암호를 해독하는 키 <br/> - 비밀 키는 다른 사람에게 알려져선 안 됨|
  - 공통 키, 공개 키 모두 데이터 , 비밀 키, 공개 키가 전부 데이터로 표현됨

**디지털 서명**

- 공개 키 방식을 응용한 예
- 본문 자체를 암호화하는 것이 아닌, 먼저 해시화하고 그 결과를 암호화함

#### 키 교환

- 클라이언트 ↔ 서버 사이에 키를 교환하는 것
- 여러 방법이 있음
  - 클라이언트에서 공통 키 생성 → 서버 인증서의 공개 키로 암호화 해 전송하는 방식
  - 키 교환 전용 알고리즘 사용 방식

**DHE 알고리즘 (일시 디피-헬먼, Diffie-Hellman ephemeral)**

- 키 자체를 교환하는 것 X
- 클라이언트와 서버에서 각자 키 재료를 만들어 교환하고 각자 계산해서 같은 키를 얻는 것
- 생성되는 키의 길이와 안전성 상관 관계
- 현재는 `2048 비트` 이상 길이 권장 (616자리 정도의 소수)
- 프록시는 계산이 불가하기 때문에 오직 클라이언트와 서버만 공통 키를 가질 수 있음

#### 공통 키 방식과 공개 키 방식을 구분해서 사용하는 이유

- 공개 키 방식은 복잡한 만큼 안전성은 높지만 계산에 걸리는 시간이 오래 소요됨
- TLS는 두 방식을 조합해서 사용
  - 통신마다 한 번만 사용되는 공통 키 생성
  - 공개 키 방식으로 상대방에게 키 전달
  - 이후 공통 키로 빠르게 암호화
- RSA와 AES
- 두 방식의 속도 차이

#### TLS 통신 절차

- handshake 프로토콜로 통신을 확립하는 단계
- record 프로토콜로 불리는 통신 단계
- Session Ticket 구조를 이용한 재접속 시의 고속 handshake

1. 서버의 신뢰성 확인

- 서버의 신뢰성을 보증하는 구조는 공개 키를 보증하는 구조이기도 하기 때문에 `공개 키 기반 구조(public key infrastructure)`라고도 불림
- 브라우저는 서버로부터 서버의 SSL 인증서를 가지고 오는 것부터 시작
- 신뢰성 확인의 핵심은 `발행자(인증기관)`

> 💡 루트 인증기관  
> 발행자과 주체자가 동일한 인증서

2. 키 교환과 통신 시작

- 공개 키 암호 사용 방법 or 키 교환 전용 알고리즘 사용 방법이 있음
  | 순서 | 주체 | 설명 |
  | --- | --- | --- |
  |1|Server > Client| SSL 서버 인증서 취득 |
  |2|Client| - 난수를 사용해 통신용 공통 키 생성 <br/> - 서버 인증서에 첨부되어 있는 공개 키로 통신용 공통 키 암호화 |
  |3|Cleind > Server| 암호화한 공통 키를 서버로 전달|
  |4|Server| 공개 키에 대응하는 비밀 키로 데이터 복호화|

3. 통신

