# Chapter 01 - HTTP/1.0의 신택스: 기본이 되는 네 가지 요소

> HTTP란?  
> 웹 브라우저와 웹 서버가 통신하는 절차와 형식을 규정한 것

<br/>

### 1.1 HTTP의 역사

#### HTTP 버전

- 1990년: HTTP/0.9
- 1996년: HTTP/1.0
- 1997년: HTTP/1.1
- 2005년: HTTP/2

#### HTTP 프로토콜과 관련된 고유 명사

| 이름   | 정식 명칭                                                   | 역할/의미                                                                     |
| ------ | ----------------------------------------------------------- | ----------------------------------------------------------------------------- |
| IETF   | The Internet Enginerring Task Force/인터넷 기술 태스크 포스 | 인터넷의 상호 접속성을 향상시키는 것을 목적으로 만들어진 임의 단체            |
| RFC    | Request For Comments                                        | IETF가 만든 규약 문서                                                         |
| IANA   | Internet Assigned Numbers Ahtority                          | 포트 번호와 파일 타입(Content-Type) 등 웹에 관한 데이터베이스를 관리하는 단체 |
| W3C    | World Wide Web Consortium                                   | 웹 관련 표준화를 하는 비영리 단체                                             |
| WHATWG | Web Hypertext Application Technology Working Group          | 웹 관련 규격을 논의하는 단체                                                  |

#### PORT

- HTTP의 디폴트 포트 → 80
- 낮은 포트 번호들은 잘 알려진 포트
- 중요한 포트이므로 이미 시스템에서 사용 중이거나 일반 사용자는 해당 포트를 이용할 수 없게 권한이 제한되어 있는 경우가 많음
- 80번 포트의 대체 포트 → 8000, 8080, 8888 등

<br/>

### 1.2 HTTP/0.9로 할 수 있는 것을 시험하다

- URL (Uniform Resource Identifier): 호스트명 + 경로
- 과정

  - 웹사이트의 페이지를 서버에 요청
  - 서버는 응답으로 웹사이트 페이지를 전송
  - 웹사이트의 페이지를 수신하면 연결은 끊어짐

<br/>

### 1.3 HTTP/0.9에서 1.0d으로의 여정

- 요청
  - 요청 메서드 추가 (GET)
  - HTTP 버전 추가 (HTTP/1.0)
  - 요청 헤더 추가 (Host, User-Agent, Accept)
- 응답
  - HTTP 버전과 Status Code 추가 (200)
  - 응답 헤더 추가 (Content-Length, Content-Type)

<br/>

### 1.4 HTTP의 조상 (1) 전자메일

- HTTP의 요청, 응답 헤더의 기원은 전자 메일 시스템
- 전자 메일의 헤더에는 본문 이외의 모든 정보가 포함되어 있음
- HTTP의 헤더에는 서버와 클라이언트 사이에 필요햔 추가 정보, 지시, 명령, 당부 등이 포함되어 있음

#### 대표적인 헤더

- 클라이언트 → 서버
  - User-Agent: 클라이언트가 자신의 애플리케이션의 이름을 넣는 곳으로, `브라우저의 종류와 버전` 구분 가능
  - Referer: 클라이언트가 서버로 요청 시 보고 있던 페이지의 `URL`
  - Authorization: 특정 클라이언트와의 통신을 위한 인증 정보
    - RFC에서는 `Basic, Digest, Berear` 이라는 몇 가지 표준 형식을 정함
    - 다만 AWS, Github 등 서비스에 따라 자체 표기를 요구하는 경우도 있음
- 서버 → 클라이언트
  - Content-Type: 파일 종류
  - Content-Length: 응답 바디의 크기로, 압축이 적용됐다면 압축 후의 크기
  - Content-Encoding: 압축이 적용된 경우 압축 형식
  - Date: 문서 날짜

> 💡 `X-`로 시작하는 헤더는 자유롭게 커스텀이 가능한 헤더

#### 헤더 전송

- RFC에서는 같은 헤더를 동시에 여러 개 보내는 것도 허용
- 동시에 수신한 복수의 헤더를 처리하는 방법은 언어 및 프레임워크에 따라 다름
- 헤더 중에는 `요청`에만 사용되는 것, `응답`에만 사용되는 것, `양쪽`에 모두 사용되는 것이 있음

#### MIME 타입

- 파일의 종류를 구분하는 문자열로, 전자메일을 위해 만들어짐
- 각 파일을 더블클릭했을 때 형식에 따라 어떤 애플리케이션을 실행할 지 → OS가 관리
- OS와 별도로 파일 종류별로 어떻게 동작할 지 → 브라우저가 관리
- 사진과 동영상은 브라우저나 환경에 따라 이용할 수 있는 포맷이 다름

#### Content-Type과 보안

> 💡 `콘텐트 스니핑(content snigging)`이란?
>
> 브라우저가 MIME 타입이 아닌 내용을 보고 파일 형식을 추측하는 것으로,
> 사용자가 편할 것 같지만, 의도하지 않게 파일을 실행시켜 버리는 오류도 종종 발생하므로 보안상 좋지 않음

- 브라우저가 마음대로 파일 형식을 추측하지 않도록 하는 방법
  - 서버에서 응답 헤더에 아래와 같은 옵션 추가
  ```tsx
  X-Content-Type-Options: nosniff
  ```

#### HTTP와 전자메일 비교

- 공통점
  - 헤더 + 본문 구조를 가지고 있음
- 차이점
  - HTTP 요청에서는 선두에 method + path 행이 추가됨
  - HTTP 응답에서는 선두에 Status Code가 추가됨

<br/>

### 1.5 HTTP의 조상 (2) 뉴스그룹

#### Method

- `뉴스그룹`에서 가져온 기능 중 하나
- 지정된 주소에 있는 리소스에 대한 조작을 서버에 지시
- 실제 브라우저가 표준 기능만으로 메서드를 통해 서버에 요청을 보낼 수 있게 된 건 자바스크립트에서 `XMLHttpRequest`를 지원하고 난 후부터임
- HTML의 폼에서는 `GET`과 `POST`만 지원

#### Status Code

- `뉴스그룹`에서 가져온 기능 중 하나
- 크게 5가지 카테고리
  - 100 번대: 처리가 계속됨
  - 200 번대: 성공
  - 300 번대: 서버 → 클라이언트 명령으로, 오류가 아닌 정상 처리의 범주 (리다이렉트 or 캐시 이용 등을 지시)
  - 400 번대: 클라이언트에서 보낸 요청에 오류 존재
  - 500 번대: 서버 내부에서 오류 발생

<br/>

### 1.6 Redirect

- `300` 번대의 Status Code는 서버사 브라우저에 대해 `리다이렉트를 지시`하는 코드임
- 300 번 이외의 경우에는 `Location 헤더`를 사용해 리다이렉트 할 곳을 서버 → 클라이언트로 전달
- 리다이렉트가 `영구적`인지 `일시적`인지는 이동하는 이전 페이지가 이후에도 존재하는지로 분류
- 리다이렉트하는 곳이 다른 서버라면 리다이렉트할 때마다 TCP 세션에 접속한 후 HTTP 통신을 해야 하므로 리다이렉트 수가 늘어나면 그만큼 화면 표시에 걸리는 시간도 늘어날 수 있음

<br/>

### 1.7 URL

- URI: URN이라는 이름 부여 규칙도 포함
  - URN에는 이름밖에 없기 때문에 위치를 알려면 별도의 정보가 필요함
- URL: 경로로 문서 등의 리소스를 특정하는 수단을 제공

#### URL의 구조

> 💡 https://www.naver.com/smartstore
>
> 스키마://호스트명/경로  
> 풀 구성 → 스키마://사용자:패스워드@호스트명:포트/경로#프래그먼트?쿼리

- 구조
  - 스키마: https
  - 호스트명: www.naver.com
  - 경로: smartstore
- 스키마 해석은 브라우저의 역할
- 실제로 통신하는 곳 → 호스트명으로 지정된 서버
- 포트는 아파트 등의 현관 우편함 같은 것
  - 호스트 명이 같더라도 포트가 다르면 복수의 서버를 이용해 서비스를 제공할 수 있음
- 포트가 생략되면 스키마별 기본 포트를 사용
  - HTTP: 80
  - HTTPS: 443
- 사용자 이름과 패스워드는 FTP에서 사용되고는 하며, 웹에서는 사용되는 일이 거의 없음
- 프래그먼트는 HTML에서 페이지 내 링크의 앵커를 지정하는 데 사용
- 쿼리는 검색 용어 지정, 페이지 내 특정 파라미터를 부여하는 데 사용

#### URL과 국제화

- 퓨니코드란
  - 한글, 중국어 등 반각 영숫자가 아닌 문자를 정해진 규칙에 따라 반각 영숫자로 치환하는 규칙

<br/>

### 1.8 바디

- HTTP/1.0
  - 요청과 응답의 헤더와 바디가 분리되기 시작
  - 요청에도 콘텐츠를 포함할 수 있게 됨
- 헤더의 끝에 빈 줄을 넣으면 그 이후는 모두 바디가 됨
- 속도를 위해 바디를 압축하는 경우도 있음
  - Content-Encoding: 압축되어 있는 바디의 데이터를 읽을 알고리즘 방식
  - Content-Length: 압축 전 콘텐츠의 길이 X, 압축 후 통신 데이터 크기

#### GET 요청 시의 바디

- GET은 바디를 포함하는 것이 기대되지 않는 메서드
- 요청에 바디를 포함할 수 는 있지만 구현에 따라서 서버가 이를 받아들이지 않고 거부하는 경우가 있을 수 있기 때문에 유용하지 않음
- GET, HEAD, DELETE, OPTIONS, CONNECT 등이 있음
  - 바디의 시맨틱스를 정하지 않은 메서드
